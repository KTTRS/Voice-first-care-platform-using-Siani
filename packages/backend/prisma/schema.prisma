generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum UserRole {
  ADMIN
  DOCTOR
  NURSE
  PATIENT
  CAREGIVER
  CHW // Community Health Worker
  PAYER // Insurance/payer organization
}

enum SignalType {
  VITAL_SIGN
  SYMPTOM
  MEDICATION
  MOOD
  ACTIVITY
}

enum SignalSeverity {
  LOW
  MEDIUM
  HIGH
  CRITICAL
}

enum ReferralStatus {
  PENDING
  ACCEPTED
  COMPLETED
  CANCELLED
}

model User {
  id        String   @id @default(uuid())
  email     String   @unique
  password  String
  firstName String
  lastName  String
  role      UserRole @default(PATIENT)
  phone     String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  patientsAsDoctor  Patient[]      @relation("DoctorPatients")
  patientsAsNurse   Patient[]      @relation("NursePatients")
  patientProfile    Patient?       @relation("UserPatient")
  signals           Signal[]
  referralsCreated  Referral[]     @relation("CreatedReferrals")
  referralsReceived Referral[]     @relation("ReceivedReferrals")
  memories          Memory[]
  memoryMoments     MemoryMoment[]
  goals             Goal[]
  dailyActions      DailyAction[]
  referralLoops     ReferralLoop[]
  signalEvents      SignalEvent[]
  feedEvents        FeedEvent[]
  signalScores      SignalScore[]
  resourceEngagements ResourceEngagement[]
  relationalMemories RelationalMemory[]
  relationalContext  RelationalContext?

  @@map("users")
}

model Patient {
  id     String @id @default(uuid())
  userId String @unique
  user   User   @relation("UserPatient", fields: [userId], references: [id], onDelete: Cascade)

  dateOfBirth        DateTime
  medicalHistory     String?
  allergies          String?
  currentMedications String?
  emergencyContact   String?

  assignedDoctorId String?
  assignedDoctor   User?   @relation("DoctorPatients", fields: [assignedDoctorId], references: [id])

  assignedNurseId String?
  assignedNurse   User?   @relation("NursePatients", fields: [assignedNurseId], references: [id])

  createdAt DateTime @default(now())
  goals     goals?   @relation(fields: [goalId], references: [id])
  users     users    @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model feed_events {
  id        String   @id
  type      String
  userId    String
  goalId    String?
  message   String
  createdAt DateTime @default(now())
  updatedAt DateTime
  goals     goals?   @relation(fields: [goalId], references: [id])
  users     users    @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([createdAt])
  @@index([type])
  @@index([userId])
}

model goals {
  id            String          @id
  userId        String
  title         String
  points        Int
  isActive      Boolean         @default(true)
  createdAt     DateTime        @default(now())
  daily_actions daily_actions[]
  feed_events   feed_events[]
  users         users           @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model memories {
  id             String   @id
  content        String
  embedding      String?
  metadata       Json?
  userId         String
  conversationId String?
  importance     Float    @default(0.5)
  createdAt      DateTime @default(now())
  accessedAt     DateTime @default(now())
  users          users    @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([importance])
  @@index([userId, conversationId])
}

model memory_moments {
  id        String   @id
  userId    String
  content   String
  emotion   String
  tone      String
  vectorId  String
  source    String?  @default("text")
  metadata  Json?
  createdAt DateTime @default(now())
  users     users    @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model patients {
  id                                     String      @id
  userId                                 String      @unique
  dateOfBirth                            DateTime
  medicalHistory                         String?
  allergies                              String?
  currentMedications                     String?
  emergencyContact                       String?
  assignedDoctorId                       String?
  assignedNurseId                        String?
  createdAt                              DateTime    @default(now())
  updatedAt                              DateTime
  users_patients_assignedDoctorIdTousers users?      @relation("patients_assignedDoctorIdTousers", fields: [assignedDoctorId], references: [id])
  users_patients_assignedNurseIdTousers  users?      @relation("patients_assignedNurseIdTousers", fields: [assignedNurseId], references: [id])
  users_patients_userIdTousers           users       @relation("patients_userIdTousers", fields: [userId], references: [id], onDelete: Cascade)
  referrals                              referrals[]
  signals                                signals[]
}

model referral_loops {
  id        String   @id
  userId    String
  resource  String
  status    String
  createdAt DateTime @default(now())
  updatedAt DateTime
  users     users    @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model referrals {
  id                                String         @id
  status                            ReferralStatus @default(PENDING)
  reason                            String
  notes                             String?
  priority                          Int            @default(1)
  patientId                         String
  fromUserId                        String
  toUserId                          String
  createdAt                         DateTime       @default(now())
  updatedAt                         DateTime
  completedAt                       DateTime?
  users_referrals_fromUserIdTousers users          @relation("referrals_fromUserIdTousers", fields: [fromUserId], references: [id])
  patients                          patients       @relation(fields: [patientId], references: [id], onDelete: Cascade)
  users_referrals_toUserIdTousers   users          @relation("referrals_toUserIdTousers", fields: [toUserId], references: [id])

  @@index([patientId])
  @@index([status])
}

model resource_engagements {
  id               String    @id
  userId           String
  resourceId       String?
  resourceName     String    @default("")
  resourceType     String    @default("")
  needType         String
  status           String
  confidence       Float?
  detectionContext String?
  detectedAt       DateTime  @default(now())
  offeredAt        DateTime?
  acceptedAt       DateTime?
  declinedAt       DateTime?
  completedAt      DateTime?
  failedAt         DateTime?
  followedUpAt     DateTime?
  closedAt         DateTime?
  lastFollowUpAt   DateTime?
  successRating    Int?
  impactNotes      String?
  offeredBy        String?
  declineReason    String?
  metadata         Json      @default("{}")
  createdAt        DateTime  @default(now())
  updatedAt        DateTime
  users            users     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([createdAt])
  @@index([detectedAt])
  @@index([needType])
  @@index([status])
  @@index([userId])
}

model signal_events {
  id        String   @id
  userId    String
  type      String
  delta     Float
  createdAt DateTime @default(now())
  users     users    @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model signal_scores {
  id                  String    @id
  userId              String
  medicationAdherence Float     @default(0)
  mentalHealthRisk    Float     @default(0)
  socialIsolation     Float     @default(0)
  careCoordination    Float     @default(0)
  systemTrust         Float     @default(0)
  overallRisk         Float     @default(0)
  trendMedication     Float     @default(0)
  trendMentalHealth   Float     @default(0)
  trendSocial         Float     @default(0)
  totalMoments        Int       @default(0)
  totalGoalsCompleted Int       @default(0)
  streakDays          Int       @default(0)
  lastActivityAt      DateTime?
  detectedNeeds       String[]  @default([])
  sdohRisk            Float     @default(0)
  createdAt           DateTime  @default(now())
  updatedAt           DateTime
  users               users     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([createdAt])
  @@index([overallRisk])
  @@index([userId])
}

model signals {
  id           String         @id
  type         SignalType
  severity     SignalSeverity @default(LOW)
  value        String
  metadata     Json?
  score        Float          @default(0)
  patientId    String
  recordedById String
  timestamp    DateTime       @default(now())
  createdAt    DateTime       @default(now())
  patients     patients       @relation(fields: [patientId], references: [id], onDelete: Cascade)
  users        users          @relation(fields: [recordedById], references: [id])

  @@index([patientId, timestamp])
  @@index([severity])
}

model users {
  id                                        String                 @id
  email                                     String                 @unique
  password                                  String
  firstName                                 String
  lastName                                  String
  role                                      UserRole               @default(PATIENT)
  phone                                     String?
  createdAt                                 DateTime               @default(now())
  updatedAt                                 DateTime
  daily_actions                             daily_actions[]
  feed_events                               feed_events[]
  goals                                     goals[]
  memories                                  memories[]
  memory_moments                            memory_moments[]
  patients_patients_assignedDoctorIdTousers patients[]             @relation("patients_assignedDoctorIdTousers")
  patients_patients_assignedNurseIdTousers  patients[]             @relation("patients_assignedNurseIdTousers")
  patients_patients_userIdTousers           patients?              @relation("patients_userIdTousers")
  referral_loops                            referral_loops[]
  referrals_referrals_fromUserIdTousers     referrals[]            @relation("referrals_fromUserIdTousers")
  referrals_referrals_toUserIdTousers       referrals[]            @relation("referrals_toUserIdTousers")
  resource_engagements                      resource_engagements[]
  signal_events                             signal_events[]
  signal_scores                             signal_scores[]
  signals                                   signals[]
}

enum ReferralStatus {
  PENDING
  ACCEPTED
  COMPLETED
  CANCELLED
}

enum SignalSeverity {
  LOW
  MEDIUM
  HIGH
  CRITICAL
}

enum SignalType {
  VITAL_SIGN
  SYMPTOM
  MEDICATION
  MOOD
  ACTIVITY
}

enum UserRole {
  ADMIN
  DOCTOR
  NURSE
  PATIENT
  CAREGIVER
}

model RelationalMemory {
  id        String   @id @default(cuid())
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  // Content and context
  content   String   // The conversation content
  emotionVector String // JSON: [calm, guarded, lit] scores
  topics    String   // JSON: array of topic strings
  
  // Vector embedding for similarity search
  embedding String   // JSON: conversation embedding vector
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([userId])
  @@index([createdAt])
  @@map("relational_memories")
}

model RelationalContext {
  id        String   @id @default(cuid())
  userId    String   @unique
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  // Aggregated relational metrics
  topics    String   // JSON: array of recurring topics
  emotionVectorMean String // JSON: average emotional state
  
  // Trust and continuity scores (0-1)
  trustIndex      Float @default(0.5) // Frequency of emotionally open moments
  resonanceIndex  Float @default(0.5) // Emotional convergence with Siani
  continuityScore Float @default(0.5) // Emotional/topical overlap between sessions
  
  lastUpdate DateTime @default(now())
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  @@index([userId])
  @@map("relational_contexts")
}

model AuditLog {
  id        String   @id @default(cuid())
  
  // User and action details
  userId    String?  // Nullable for failed login attempts (user may not exist)
  action    String   // e.g., "LOGIN", "LOGOUT", "REGISTER", "SCOPE_CHECK", "TOKEN_REFRESH"
  resource  String?  // Resource being accessed (e.g., "/api/signals", "patient:read")
  
  // Result
  success   Boolean  @default(true)
  errorMessage String? // Error details for failed actions
  
  // Request metadata
  ipAddress String?
  userAgent String?
  
  timestamp DateTime @default(now())

  @@index([userId])
  @@index([action])
  @@index([timestamp])
  @@index([success])
  @@map("audit_logs")
}

model RelationalMemory {
  id        String   @id @default(cuid())
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  // Content and context
  content   String   // The conversation content
  emotionVector String // JSON: [calm, guarded, lit] scores
  topics    String   // JSON: array of topic strings
  
  // Vector embedding for similarity search
  embedding String   // JSON: conversation embedding vector
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([userId])
  @@index([createdAt])
  @@map("relational_memories")
}

model RelationalContext {
  id        String   @id @default(cuid())
  userId    String   @unique
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  // Aggregated relational metrics
  topics    String   // JSON: array of recurring topics
  emotionVectorMean String // JSON: average emotional state
  
  // Trust and continuity scores (0-1)
  trustIndex      Float @default(0.5) // Frequency of emotionally open moments
  resonanceIndex  Float @default(0.5) // Emotional convergence with Siani
  continuityScore Float @default(0.5) // Emotional/topical overlap between sessions
  
  lastUpdate DateTime @default(now())
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  @@index([userId])
  @@map("relational_contexts")
}

model AuditLog {
  id        String   @id @default(cuid())
  
  // User and action details
  userId    String?  // Nullable for failed login attempts (user may not exist)
  action    String   // e.g., "LOGIN", "LOGOUT", "REGISTER", "SCOPE_CHECK", "TOKEN_REFRESH"
  resource  String?  // Resource being accessed (e.g., "/api/signals", "patient:read")
  
  // Result
  success   Boolean  @default(true)
  errorMessage String? // Error details for failed actions
  
  // Request metadata
  ipAddress String?
  userAgent String?
  
  timestamp DateTime @default(now())

  @@index([userId])
  @@index([action])
  @@index([timestamp])
  @@index([success])
  @@map("audit_logs")
}
